package DynamicProgramming;

/** 
 * BlocKOut [方块消除] n个带颜色的方块排成一行，相同颜色且区域相邻的方块群可消，
 * 方块消去后产生空列，此时右边的方块会向左移动，直到所有方块相连，
 * x为可消区域内方块个数，得分为x^2, int[]表示初始方块布局(不同数字代表不同颜色)，求最大得分
 * 
 * describe:动规
 * 本题属于区间dp型问题，不过在设置状态时不是特别容易。设dp[i][j]表示i-j之间的最大得分,那么有2种方法：
 * 1.找到从j开始向左延伸到p,直接把p-j这一段消除;
 * 2.从i开始向右延伸到q,且a[q]==a[j], a[q+1]!=a[j]。这样中间的q+1..p-1一定是可以被消除的，然后2段连接到一起;
 * 不过第二种方法仅仅用dp(i,j)还是不能准确的描述清楚, 因此我们增加一个维度，用dp(i,j,k)表示
 * 原序列i-j的右边再增加k个颜色等于a[j]的方块所得的新序列”的最大得分。这样，2种决策都可以用如下状态转移方程描述了：
 * dp(i,j,k) = dp(i,p-1,0)+(j-i+k+1)*(j-i+k+1)(p是从j开始向左延伸的最远的下标)
 * dp(i,j,k) = max{dp(q+1,p-1,0)+dp(i,q,j-p+k+1)}(p满足a[q]==a[j]&&a[q+1]!=a[j])
 * 不难发现，状态一共有O(n^3)个，决策有O(n)个，因此时间复杂度为O(n^4)。
 * 可以用记忆化搜索的方法来求解。由于q的取值范围一般都比较小，因此对于大部分数据，这个算法的运行效率都很高。
 * (不会做)
 */
public class BlocKOut {
 	
	public static void main(String[] args) { 
		
	} 

}
